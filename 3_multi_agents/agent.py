"""
This module defines a multi-agent system with tools and agents for various tasks, including math, string analysis, and memory management.
"""

import asyncio
import json
import os
import sys
from datetime import datetime
from dotenv import load_dotenv
from openai import AsyncOpenAI

load_dotenv()
api_key = os.getenv("OPENAI_API_KEY")
client = AsyncOpenAI(api_key=api_key)

# ------------------------------
# Agent and Tool Registries
# ------------------------------
tool_registry = {}            # Global default tools (shared)
agent_tools = {}              # agent_name -> tool_name -> fn
agent_registry = {}           # agent_name -> fn
memory_log = []

# ------------------------------
# Decorators
# ------------------------------
def agent(name):
    """
    Decorator to register a function as an agent.

    Args:
        name (str): The name of the agent.

    Returns:
        function: The decorated function.
    """
    def decorator(fn):
        agent_registry[name] = fn
        return fn
    return decorator

def tool(agent=None):
    """
    Decorator to register a function as a tool, optionally for a specific agent.

    Args:
        agent (str, optional): The name of the agent to associate the tool with. Defaults to None.

    Returns:
        function: The decorated function.
    """
    def decorator(fn):
        name = fn.__name__
        if agent:
            agent_tools.setdefault(agent, {})[name] = fn
        else:
            tool_registry[name] = fn
        return fn
    return decorator

# ------------------------------
# Logger Utility
# ------------------------------
class Logger:
    """
    Utility class for logging tool and agent interactions.

    Attributes:
        path (str): The file path for the log file.
    """
    def __init__(self, path="agent_trace_log.jsonl"):
        """
        Initializes the Logger with a specified log file path.

        Args:
            path (str): The file path for the log file.
        """
        self.path = path

    async def log(self, **kwargs):
        """
        Logs a dictionary of information to the log file.

        Args:
            **kwargs: Arbitrary keyword arguments to log.
        """
        kwargs["timestamp"] = datetime.utcnow().isoformat()
        print("[LOG]", kwargs)
        with open(self.path, "a") as f:
            f.write(json.dumps(kwargs) + "\n")

logger = Logger()

# ------------------------------
# Tools for Math Agent
# ------------------------------
@tool(agent="math")
def add(a, b): 
    """Adds two numbers."""
    return a + b

@tool(agent="math")
def multiply(a, b):
     """Multiplies two numbers."""
     return a * b

@tool(agent="math")
def power(a, b): 
    """Raises a to the power of b."""
    return a ** b

# ------------------------------
# Tools for String Agent
# ------------------------------
@tool(agent="string")
def word_count(s):
     """Counts the number of words in a string."""
     return len(s.split())

@tool(agent="string")
def letter_count(s):
    """Counts the number of letters (a-z, A-Z) in a string."""
    return sum(c.isalpha() for c in s)

# ------------------------------
# Memory Agent
# ------------------------------
@agent("memory")
async def memory_agent(task, memory_log):
    if not memory_log:
        return {"result": "Memory is empty."}
    task = task.lower()
    try:
        if "question" in task:
            return {"result": memory_log[-1][0]}
        elif "answer" in task or "result" in task:
            return {"result": memory_log[-1][1]}
        else:
            index = int(task)
            return {"result": memory_log[index][1]}
    except:
        return {"result": f"Memory access unclear: {task}"}

# ------------------------------
# Planner Agent
# ------------------------------
@agent("planner")
async def planner_agent(prompt, memory_log):
    context = "\n".join([f"- {q} â†’ {r}" for q, r in memory_log[-5:]]) or "No history."
    available_agents = [a for a in agent_registry.keys() if a != "planner"]
    agent_list = "\n".join([f"- {a}" for a in available_agents])
    system_msg = (
        f"You are a routing agent.\nAvailable agents:\n{agent_list}\n\n"
        f"Recent memory:\n{context}\n\n"
        f"Decide which agent to use and what task to pass it.\n"
        f"Return JSON like: {{\"agent\": \"math\", \"task\": \"Add 3 and 5\"}}"
    )
    res = await client.chat.completions.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": system_msg},
            {"role": "user", "content": prompt}
        ]
    )
    return json.loads(res.choices[0].message.content)

# ------------------------------
# Generic Tool-Based Agent Execution
# ------------------------------
async def execute_plan(user_prompt, agent=None):
    """
    Executes a plan generated by the LLM using the specified tools.

    Args:
        user_prompt (str): The user's input prompt.
        agent (str, optional): The name of the agent to use. Defaults to None.

    Returns:
        dict: The final result and the steps taken during execution.
    """
    toolset = agent_tools.get(agent, tool_registry)
    tool_list = "\n".join([f"{name}: {fn.__doc__.strip()}" for name, fn in toolset.items()])

    system_msg = (
        "You are a reasoning agent. Break the user's prompt into tool calls.\n"
        f"Available tools:\n{tool_list}\n\n"
        "Return JSON like:\n"
        '[{"tool": "word_count", "args": ["hello world"], "reasoning": "count words"}]'
    )

    res = await client.chat.completions.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": system_msg},
            {"role": "user", "content": user_prompt}
        ]
    )

    raw_plan = res.choices[0].message.content
    print("\n[LLM PLAN]", raw_plan)
    plan = json.loads(raw_plan)

    steps_log = []
    last_result = None

    try:
        for step in plan:
            tool_name = step["tool"]
            args = step["args"]
            reasoning = step.get("reasoning", "")
            args = [last_result if str(a).lower() == "previous" else a for a in args]

            if tool_name in toolset:
                result = toolset[tool_name](*args)
            else:
                await logger.log(tool=tool_name, args=args, error="Unknown tool", reasoning=reasoning)
                raise ValueError(f"Unknown tool: {tool_name}")

            await logger.log(tool=tool_name, args=args, result=result, reasoning=reasoning)
            steps_log.append({"tool": tool_name, "args": args, "result": result, "reasoning": reasoning})
            last_result = result

        memory_log.append((user_prompt, last_result))
        return {"final_result": last_result, "steps": steps_log}

    except Exception as e:
        await logger.log(tool=tool_name, args=args, error=str(e))
        return {"error": str(e), "steps": steps_log}

# ------------------------------
# Agent Implementations
# ------------------------------
@agent("math")
async def math_agent(prompt, memory_log):
    return await execute_plan(prompt, agent="math")

@agent("string")
async def string_agent(prompt, memory_log):
    return await execute_plan(prompt, agent="string")

# ------------------------------
# Multi-Agent Router
# ------------------------------
async def multi_agent_router(prompt):
    plan = await planner_agent(prompt, memory_log)
    agent_name = plan.get("agent")
    task = plan.get("task")

    if agent_name not in agent_registry:
        return {"error": f"Unknown agent: {agent_name}"}

    result = await agent_registry[agent_name](task, memory_log)

    if agent_name != "planner" and isinstance(result, dict) and "result" in result:
        memory_log.append((prompt, result["result"]))

    return result

# ------------------------------
# CLI Loop
# ------------------------------
async def main():
    while True:
        prompt = input("\nAsk something (or type 'exit'): ")
        if prompt.lower() == "exit":
            break
        result = await multi_agent_router(prompt)
        print(json.dumps(result, indent=2))

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except RuntimeError as e:
        if "cannot be called from a running event loop" in str(e):
            if sys.platform == "win32":
                asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
            loop = asyncio.get_event_loop()
            loop.run_until_complete(main())
        else:
            raise
